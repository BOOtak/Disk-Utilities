/*
 * disk/copylock.c
 * 
 * Rob Northen CopyLock protection track (Amiga).
 * 
 * Written in 2011 by Keir Fraser
 * 
 * RAW TRACK LAYOUT:
 *  514 decoded bytes per sector (excluding sector gap)
 *  Inter-sector gap of ~48 decoded zero bytes (48 MFM words).
 * Decoded Sector:
 *  <sync word>   :: Per-sector sync marker, see code for list
 *  u8 index      :: 0-11, must correspond to appropriate sync marker
 *  u8 data[512]
 * Data Bytes:
 *  Generated by a 23-bit LFSR, with taps at positions 1 and 23.
 *  The data bytes are an arbitrary fixed 8-bit window on the LFSR state.
 *  The generated byte stream carries across sector boundaries.
 * Sector 6:
 *  First 16 bytes interrupt random stream with signature "Rob Northen Comp"
 *  The LFSR-generated data then continues uninterrupted at 17th byte.
 * MFM encoding:
 *  In place, no even/odd split.
 * Timings:
 *  Sync 0x8912 is 5% faster; Sync 0x8914 is 5% slower. All other bit cells
 *  are 2us, and total track length is exactly as usual (the short sector
 *  precisely balances the long sector).
 * 
 * TRKTYP_copylock data layout:
 *  u32 lfsr_seed; (Only lfsr_seed[22:0] is used and non-zero)
 *  First data byte of sector 0 is lfsr_seed[22:15].
 */

#include <libdisk/util.h>
#include "private.h"

#include <arpa/inet.h>

static const uint16_t sync_list[] = {
    0x8a91, 0x8a44, 0x8a45, 0x8a51, 0x8912, 0x8911,
    0x8914, 0x8915, 0x8944, 0x8945, 0x8951 };
static const uint8_t sec6_sig[] = {
    0x52, 0x6f, 0x62, 0x20, 0x4e, 0x6f, 0x72, 0x74, /* "Rob Northen Comp" */
    0x68, 0x65, 0x6e, 0x20, 0x43, 0x6f, 0x6d, 0x70 };

static uint32_t lfsr_prev_state(uint32_t x)
{
    return (x >> 1) | ((((x >> 1) ^ x) & 1) << 22);
}

static uint32_t lfsr_next_state(uint32_t x)
{
    return ((x << 1) & ((1u << 23) - 1)) | (((x >> 22) ^ x) & 1);
}

static uint8_t lfsr_state_byte(uint32_t x)
{
    return (uint8_t)(x >> 15);
}

/* Take LFSR state from start of one sector, to another. */
static uint32_t lfsr_seek(uint32_t x, unsigned int from, unsigned int to)
{
    unsigned int sz;

    while (from != to) {
        if (from > to)
            from--;
        sz = 512;
        if (from == 6)
            sz -= sizeof(sec6_sig);
        while (sz--)
            x = (from < to) ? lfsr_next_state(x) : lfsr_prev_state(x);
        if (from < to)
            from++;
    }

    return x;
}

static void *copylock_write_mfm(
    struct disk *d, unsigned int tracknr, struct stream *s)
{
    struct track_info *ti = &d->di->track[tracknr];
    uint32_t *block, lfsr_seed = 0, latency[11], valid_blocks = 0;
    unsigned int i, sec;

    while ((stream_next_bit(s) != -1) &&
           (valid_blocks != ((1u<<ti->nr_sectors)-1))) {

        uint8_t dat[2*512];
        uint32_t lfsr, lfsr_sec, idx_off = s->index_offset - 15;

        /* Are we at the start of a sector we have not yet analysed? */
        for (sec = 0; sec < ARRAY_SIZE(sync_list); sec++)
            if ((uint16_t)s->word == sync_list[sec])
                break;
        if ((sec == ARRAY_SIZE(sync_list)) || (valid_blocks & (1u<<sec)))
            continue;

        /* Check the sector header. */
        if (stream_next_bits(s, 16) == -1)
            break;
        if (mfm_decode_bits(MFM_all, (uint16_t)s->word) != sec)
            continue;

        /* Read and decode the sector data. */
        s->latency = 0;
        if (stream_next_bytes(s, dat, sizeof(dat)) == -1)
            break;
        mfm_decode_bytes(MFM_all, sizeof(dat)/2, dat, dat);

        /* Deal with sector 6 preamble. */
        i = 0;
        if (sec == 6) {
            if (memcmp(dat, sec6_sig, sizeof(sec6_sig)))
                continue;
            i = sizeof(sec6_sig);
        }

        /*
         * Get the LFSR start value for this sector. If we know the track LFSR
         * seed then we work it out from that, else we get it from sector data.
         */
        lfsr = lfsr_sec =
            (lfsr_seed != 0)
            ? lfsr_seek(lfsr_seed, 0, sec)
            : (dat[i] << 15) | (dat[i+8] << 7) | (dat[i+16] >> 1);

        /* Check that the data matches the LFSR-generated stream. */
        for (; i < 512; i++) {
            if (dat[i] != lfsr_state_byte(lfsr))
                break;
            lfsr = lfsr_next_state(lfsr);
        }
        if (i != 512)
            continue;

        /* All good. Finally, stash the LFSR seed if we didn't know it. */
        if (lfsr_seed == 0) {
            lfsr_seed = lfsr_seek(lfsr_sec, sec, 0);
            /* Paranoia: Reject the degenerate case of endless zero bytes. */
            if (lfsr_seed == 0)
                continue;
        }

        /* Good sector: remember its details. */
        if (!(valid_blocks & ((1u<<sec)-1)))
            ti->data_bitoff = idx_off;
        latency[sec] = s->latency;
        valid_blocks |= 1u << sec;
    }

    if (valid_blocks == 0)
        return NULL;

    /* Check validity of the non-uniform track timings. */
    if (!(valid_blocks & (1u << 5)))
        latency[5] = 514*8*2*2000; /* bodge it */
    for (sec = 0; sec < ARRAY_SIZE(latency); sec++) {
        float d = (100.0 * ((int)latency[sec] - (int)latency[5]))
            / (int)latency[5];
        if (!(valid_blocks & (1u << sec)))
            continue;
        switch (sec) {
        case 4:
            if (d > -4.5)
                printf("*** T%u: Copylock: Short sector is only "
                       "%.2f%% different\n", tracknr, d);
            break;
        case 6:
            if (d < 4.5)
                printf("*** T%u: Copylock: Long sector is only "
                       "%.2f%% different\n", tracknr, d);
            break;
        default:
            if ((d < -2.0) || (d > 2.0))
                printf("*** T%u: Copylock: Normal sector is "
                       "%.2f%% different\n", tracknr, d);
            break;
        }
    }

    /* Adjust track offset for any missing initial sectors. */
    for (sec = 0; sec < ti->nr_sectors; sec++)
        if (valid_blocks & (1u << sec))
            break;
    ti->data_bitoff -= sec * (514+48)*8*2;

    /* Magic: We can reconstruct the entire track from the LFSR seed! */
    if (valid_blocks != ((1u << ti->nr_sectors) - 1)) {
        printf("*** T%u: Reconstructed damaged Copylock track!\n", tracknr);
        valid_blocks = (1u << ti->nr_sectors) - 1;
    }

    ti->valid_sectors = valid_blocks;
    ti->len = 4;
    block = memalloc(ti->len);
    *block = htonl(lfsr_seed);
    return block;
}

static void copylock_read_mfm(
    struct disk *d, unsigned int tracknr, struct track_buffer *tbuf)
{
    struct track_info *ti = &d->di->track[tracknr];
    uint32_t lfsr = ntohl(*(uint32_t *)ti->dat);
    unsigned int i, sec;

    for (sec = 0; sec < ARRAY_SIZE(sync_list); sec++) {
        uint16_t speed =
            sec == 4 ? (SPEED_AVG * 94) / 100 :
            sec == 6 ? (SPEED_AVG * 106) / 100 :
            SPEED_AVG;
        tbuf_bits(tbuf, speed, MFM_raw, 16, sync_list[sec]);
        tbuf_bits(tbuf, speed, MFM_all, 8, sec);
        for (i = 0; i < 512; i++) {
            if ((sec == 6) && (i == 0))
                for (i = 0; i < sizeof(sec6_sig); i++)
                    tbuf_bits(tbuf, speed, MFM_all, 8, sec6_sig[i]);
            tbuf_bits(tbuf, speed, MFM_all, 8, lfsr_state_byte(lfsr));
            lfsr = lfsr_next_state(lfsr);
        }
        for (i = 0; i < 48; i++)
            tbuf_bits(tbuf, speed, MFM_all, 8, 0);
    }
}

struct track_handler copylock_handler = {
    .bytes_per_sector = 512,
    .nr_sectors = 11,
    .write_mfm = copylock_write_mfm,
    .read_mfm = copylock_read_mfm
};

/*
 * Local variables:
 * mode: C
 * c-file-style: "Linux"
 * c-basic-offset: 4
 * tab-width: 4
 * indent-tabs-mode: nil
 * End:
 */
